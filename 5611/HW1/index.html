<!DOCTYPE HTML>
<html>
  <head>
    <?php include '../../header.php';?>
  </head>
  <body>
      <?php include '../../navbar.php';?>
      <div id="projects">
        <h1 class="centerText">Particle Systems</h1>
        <hr>
        <h2>Group Members</h2>
        <ul>
            <li>Liam Tyler</li>
            <li>Bridger Herman</li>
        </ul>
        <h2>Description</h2>
        <p>The goal of this assignment was to create a particle system to help with the following four simulations: A ball bouncing on a floor, a water fountain, a fire, and fireworks. We did those, as well as a smoke simulation.</p>
        <h2>Difficulties</h2>
        <p>We had a lot of difficulties for this project, about four main ones. The first was getting the balls to be normal mapped, and calculating where the depth of the fragment should be. Next was having transparent particles and blending them properly in order. After that we had many bugs with the emitters. Lastly, getting all of the different types of particles to be on the screen simultaneously was difficult because we had to redo a lot of our structure. Overall it was a challenging project, most of it not related to the actual particle system, but how to draw it.</p>
        <h2>Code</h2>
        <a href="5607_hw1-master.zip" download>Download zip file of code</a>
        <br>
        <a href="https://github.umn.edu/tyler147/5611-hw1">Link to Github</a>
        <h2>Simulations</h2>
        <ul>
            <li>Bouncing Ball</li>
            <li>Water</li>
            <li>Fire</li>
            <li>Smoke</li>
            <li>Fireworks</li>
        </ul>
        <h2>Features</h2>
        <ul>
            <li>3D implementation</li>
            <li>3D user controlled camera</li>
            <li>Particle-Obstacle Interactions (arbitrary planes and spheres)</li>
            <li>Textured sprites for particles (besides balls)</li>
            <li>Translucent particles</li>
            <li>Benchmarks 1 - 4: Can have over 100k particles with 30+ FPS</li>
            <li>Thread parallel implementation (see below for performance details)</li>
            <li>Billboarding used for the particles</li>
            <li>Normal mapping and diffuse lighting for the balls to make them look like real spheres</li>
            <li>Point, disc, hemisphere, and sphere emitters</li>
        </ul>
        <h2>Controls</h2>
        <ul>
            <li><strong>W,A,S,D: </strong>Move the camera forward, backwards, left, and right</li>
            <li><strong>Mouse: </strong>Rotate the camera</li>
            <li><strong>P: </strong>Pause the simulation</li>
            <li><strong>Space: </strong>Emit particles from currently selected emitter</li>
            <li><strong>F: </strong>Launch Firework</li>
            <li><strong>1 - 5: </strong>Select specific emitter</li>
            <li><strong>Arrow Keys: </strong>Move the Sphere forward, backwards, left, and right</li>
        </ul>
        <h2>Tools Used</h2>
        <ul>
            <li>OpenGL for the rendering</li>
            <li>SDL2 for the window management and user interaction</li>
            <li>GLM for the vectors and matrices</li>
            <li>OpenMP for parallelizing the particle updating</li>
        </ul>
        <h2>Implementation Details</h2>
        <p>Our system in general worked as following every frame:</p>
        <ol>
            <li>Update the particles on the CPU. This would be updating the particle's position, velocity, age, and any other relevant data. Delete the old (dead) particles in this stage.</li>
            <li>Stream the data that is relevant for drawing the particles to the GPU.</li>
            <li>Draw the particles.</li>
        </ol>
        <p>To further describe each simulation:</p>
        <p>Bouncing Balls: All of our particles are billboarded quads. To make the quads seem like actual spheres though, we used normal mapping to get the correct lighting for each fragment. We also recalcuated the depth of the fragments so that intersecting spheres looks correct. These are fully opaque, and rendered first.</p>
        <p>Water: For </p>
        <p>Fire: </p>
        <p>Smoke: </p>
        <p>Fireworks: </p>
        <h2>Thread Parallel Performance</h2>
        <p>We later used OpenMP to help with the updating of the particles. To do this however, we had to change our implementation. If a particle's age is past its lifetime, we delete it bu just moving the last particle in the array into the now dead particle's spot. The problem with this, is that it cannot be done in parallel. So with OpenMP we switched it so that when a particle should be deleted, it adds the particle to a locked list, but does not delete it yet. After the updates, the deleting is done with one thread. Here were our results:</p>
          <img class="capWidth scale" src="parallel.jpg">
          <p>We were initially confused as to why we got no performance benefit. We figured out that it is due to two reasons: Caching, and the locked array. The locked array is obviously going to slow it down a little, but there aren't that many deletes per frame, so it doesn't explain everything. The rest is explained by our particle class having many attributes, so each particle is ~90 bytes. If we try to have hundreds of thousands of particles, we end up having a huge array. This means a lot of cache misses using multiple threads, and if we have not that many particles, it hardly matters whether you have parallelization or not. If we had used the 'struct of arrays' approach, instead of our 'array of structs', we would probably see improvement here.</p>
        <h2>Videos</h2>
        <iframe width="560" height="315" src="https://www.youtube.com/embed/XLc429Wvd5g" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
        <h2>Images:</h2>
        <div class="centerText">
          <img class="capWidth" src="red_bouncing_ball.png">
          <p>A snapshot of a single ball bouncing across the floor</p>
          <hr>
        </div>
        <h2>Artistic Submission:</h2>
        <div class="centerText">
          <img class="capWidth scale" src="fire_paper.jpg">
          <p>Failed attempt to texture billboards with a fire shape</p>
          <hr>
          <img class="capWidth scale" src="fire_paper_blending.jpg">
          <p>Attempt two for texturing billboards with a fire shape</p>
          <hr>
          <img class="capWidth scale" src="slinky.jpg">
          <p>Normal mapping gone wrong, except for the edges</p>
          <hr>
          <img class="capWidth scale" src="outline.jpg">
          <p>Calculating depth for normal mapped billboards gone wrong, giving an outline</p>
          <hr>
        </div>
      </div>
    </body>
</html>
